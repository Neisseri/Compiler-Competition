--------------------------- building ast ---------------------------
parse tree: 
(compUnit 
        (compUnitItem 
            (decl 
                (constDecl const 
                    (bType int) 
                    (constDef N = 
                        (initVal 
                            (exp 
                                (addExp 
                                    (mulExp 
                                        (unaryExp 
                                            (primaryExp 
                                                (number 
                                                    (intConst 1024))))))))) ;))) 
        (compUnitItem 
            (funcDef 
                (funcType void) mm ( 
                (funcFParams 
                    (funcFParam 
                        (bType int) A [ ] [ 
                        (exp 
                            (addExp 
                                (mulExp 
                                    (unaryExp 
                                        (primaryExp 
                                            (lVal N)))))) ])) ) 
                (block { 
                    (blockItem 
                        (decl 
                            (varDecl 
                                (bType int) 
                                (varDef k = 
                                    (initVal 
                                        (exp 
                                            (addExp 
                                                (mulExp 
                                                    (unaryExp 
                                                        (primaryExp 
                                                            (lVal A [ 
                                                                (exp 
                                                                    (addExp 
                                                                        (mulExp 
                                                                            (unaryExp 
                                                                                (primaryExp 
                                                                                    (number 
                                                                                        (intConst 1))))))) ] [ 
                                                                (exp 
                                                                    (addExp 
                                                                        (mulExp 
                                                                            (unaryExp 
                                                                                (primaryExp 
                                                                                    (number 
                                                                                        (intConst 2))))))) ])))))))) ;))) }))) 
        (compUnitItem 
            (decl 
                (varDecl 
                    (bType int) 
                    (varDef A [ 
                        (exp 
                            (addExp 
                                (mulExp 
                                    (unaryExp 
                                        (primaryExp 
                                            (lVal N)))))) ] [ 
                        (exp 
                            (addExp 
                                (mulExp 
                                    (unaryExp 
                                        (primaryExp 
                                            (lVal N)))))) ]) ;))) 
        (compUnitItem 
            (decl 
                (varDecl 
                    (bType int) 
                    (varDef B [ 
                        (exp 
                            (addExp 
                                (mulExp 
                                    (unaryExp 
                                        (primaryExp 
                                            (lVal N)))))) ] [ 
                        (exp 
                            (addExp 
                                (mulExp 
                                    (unaryExp 
                                        (primaryExp 
                                            (lVal N)))))) ]) ;))) 
        (compUnitItem 
            (decl 
                (varDecl 
                    (bType int) 
                    (varDef C [ 
                        (exp 
                            (addExp 
                                (mulExp 
                                    (unaryExp 
                                        (primaryExp 
                                            (lVal N)))))) ] [ 
                        (exp 
                            (addExp 
                                (mulExp 
                                    (unaryExp 
                                        (primaryExp 
                                            (lVal N)))))) ]) ;))) 
        (compUnitItem 
            (funcDef 
                (funcType 
                    (bType int)) main ( ) 
                (block { 
                    (blockItem 
                        (stmt return 
                            (exp 
                                (addExp 
                                    (mulExp 
                                        (unaryExp 
                                            (primaryExp 
                                                (number 
                                                    (intConst 0))))))) ;)) }))) <EOF>)
visitCompUnit
visitConstDecl: int start
visitConstDecl: ident: N
visitConstDecl: initVal
visitInit
visitPrimaryExp_ number
visitCompUnit: funcDef
visitArrayParam
visitArrayParam: dim_ is not nullptr
construct funct block: mm
visitVarDecl: int start
visitVarDecl: ident: k
visitVarDecl: initVal
visitInit
visitPrimaryExp_ number
visitPrimaryExp_ number
visitBlock done!
construct funct block done!
visitVarDecl: int start
visitVarDecl: array dim_size=2
visitVarDecl: ident: A
visitVarDecl: int start
visitVarDecl: array dim_size=2
visitVarDecl: ident: B
visitVarDecl: int start
visitVarDecl: array dim_size=2
visitVarDecl: ident: C
visitCompUnit: funcDef
construct funct block: main
visitPrimaryExp_ number
visitBlock done!
construct funct block done!
visitCompUnit end create new program
visitCompUnit end create new program end
------------------------------type check------------------------------
Info: visitProgramProgram
Info: visitVarDef i32 @N = 1024
Info: visitExpr1024
Info: visitAssignmentExpr1024
Info: visitExpr1024
Info: visitIntLiteralExpr1024
ret->type 0x55d8b7fc8fd0
Info: visitFuncDefvoid @mm(i32 @A[0, @N])
Info: visitParamDefi32 @A[0, @N]
Info: visitBlock
Info: visitVarDef i32 @k = @A[1][2]
Info: visitExpr@A[1][2]
Info: visitAssignmentExpr@A[1][2]
Info: visitExpr@A[1][2]
Info: visitLvalExpr@A[1][2]
Info: lval->indices->children.size() 2
Info: visitDims 1
Info: visitExpr1
Info: visitIntLiteralExpr1
ret->type 0x55d8b7fcaa10
Info: visitDims 2
Info: visitExpr2
Info: visitIntLiteralExpr2
ret->type 0x55d8b7fc7d70
Info: function mm has no returnscope id1
Info: visitVarDef i32 @A[@N, @N]
Info: var_def->indices->children.size() 2
Info: visitDims @N
Info: visitExpr@N
Info: visitLvalExpr@N
Info: visitDims @N
Info: visitExpr@N
Info: visitLvalExpr@N
Info: visitVarDef i32 @B[@N, @N]
Info: var_def->indices->children.size() 2
Info: visitDims @N
Info: visitExpr@N
Info: visitLvalExpr@N
Info: visitDims @N
Info: visitExpr@N
Info: visitLvalExpr@N
Info: visitVarDef i32 @C[@N, @N]
Info: var_def->indices->children.size() 2
Info: visitDims @N
Info: visitExpr@N
Info: visitLvalExpr@N
Info: visitDims @N
Info: visitExpr@N
Info: visitLvalExpr@N
Info: visitFuncDefi32 @main()
Info: visitBlock
Info: visitStatementReturn 0
Info: visitExpr0
Info: visitIntLiteralExpr0
ret->type 0x55d8b7fc74f0
Info: visitReturnStmtReturn 0function has returnscope id3
ast: 
Program
  i32 @N#0 = 1024
  void @mm(i32 @A#1[0, @N])
    {
      i32 @k#2 = @A#1[1][2]
      Return 0
    }
  i32 @A#0[@N#0, @N#0]
  i32 @B#0[@N#0, @N#0]
  i32 @C#0[@N#0, @N#0]
  i32 @main()
    {
      Return 0
    }
End of Program
--------------------------- building ir_origin ---------------------------
visitProgram
visit decl global var
visit_global_init
visitExpressionVal
visitExpressionVal
visitExpressionVal
visit decl global const var N#0: 1024
visit decl global var done
visitFunction mm
visitFunction param decl: A#1
visitFunction param decl array dim:visitExpressionVal
 0visitExpressionVal
const vat not found: N
compiler: /home/2021010844/Compiler-Competition/src/frontend/IR/irgenerator.hpp:380: int IRGenerator::visitExpressionVal(std::unique_ptr<frontend::ast::Expression>&): Assertion `false' failed.
